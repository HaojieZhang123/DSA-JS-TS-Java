# Sorting Algorithms

This lesson introduces the simplest sorting algorithm—Bubble Sort—and then transitions into essential dynamic data structures like Linked Lists, Stacks, and Queues.

Later lessons will cover another sorting algorithm that require recursion.

# Bubble Sort

Bubble Sort is the simplest comparison-based sort.
It works by repeatedly swapping adjacent elements if they are out of order.
Although inefficient, it is easy to understand and implement.

## Definition

An array is considered sorted if for every index $i$, 
$$arr[i] \leq arr[i+1]$$

Given an unsorted array 
```txt
[ 1, 3, 7, 4, 2 ]
```

Bubble sort compares adiacent elements:
- Starts at index 0
- Compares `arr[i]` with `arr[i+1]`
- If `arr[j] > arr[j+1]`, swap them.
- Continue to the next pair of elements.
- After a full pass, the largest element **bubbles up** to the end of the array.

## Complexity

Iteration 1: compares n elements
Iteration 2: compares n-1 elements
Iteration 3: compares n-2 elements
...

Iteration n: compares 1 element

This is the series:

$$n + (n-1) + (n-2) + ... + 1 = \frac{n(n+1)}{2} = O(n^2)$$

Time complexity: $O(n^2)$

## Implementation of Bubble Sort

```ts
function bubbleSort(arr: number[]): void {
    let n = arr.length;

    for (let i = 0; i < n; i++) {
        let swapped = false;

        for (let j = 0; j < n - i - 1; j++) {
            // if this pair is out of order
            if (arr[j] > arr[j + 1]) {
                // swap
                let temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;

                swapped = true;
            }
        }

        // if no swaps were made, the array is sorted. Exit early
        if (!swapped) break;
    }
}
```

# Linked List Data Structure

Arrays have limitations:

- inserting in the middle is expensive: O(n)
- deleting in the middle is expensive: O(n)
- resizing requires new memory
- memory must be contiguous

Linked Lists solve these issues using **nodes** that are connected with pointers.

## Linked Lists

Each node contains:
- a value
- a pointer to the next node
- (optional) a pointer to the previous node (doubly linked list)

```
A -> B -> C -> D -> E
```

Nodes can live anywhere in memory. No contiguous block required.

## Singly vs Doubly Linked Lists

### Singly Linked Lists

```
A -> B -> C -> D -> E
```
- Node has: `value`, `next`
- Can only traverse forward
- Lighter memory footprint

### Doubly Linked Lists

```
A <-> B <-> C <-> D <-> E
```
- Node has: `value`, `next`, `prev`
- Can traverse forward and backward
- Slightly heavier memory footprint

## Insertions and Deletions

### Insertions

We modify the `next` pointer of the previous node to point to the new node.
And the `prev` pointer of the new node to point to the previous node.

We also modify the `prev` pointer of the next node to point to the new node.

- Insertion at the beginning: $O(1)$
- Insertion at the end: $O(1)$
- Insertion in the middle: $O(n)$ (traverse the list)

### Deletions

We modify the `next` pointer of the previous node to point to the next node.
And the `prev` pointer of the next node to point to the previous node.

- Deletion at the beginning: $O(1)$
- Deletion at the end: $O(1)$
- Deletion in the middle: $O(n)$ (traverse the list)

In Linked Lists there is no index, we simply traverse the list.

Linked lists use heap-allocated objects, which means node are stored in memory location that are typically more expensive than stack memory.
Each node is a separate object containing value and pointers to other nodes.

## Linked List Complexity

If we have objects pointing to head and tail (direct references to these nodes), getting head and tail has a constant time complexity: $O(1)$

Insertion and deletion has a constant time complexity: $O(1)$

Insertion and deletion at the beginning or end has a constant time complexity: $O(1)$

Insertion and deletion in the middle has a linear time complexity, since we have to traverse the list: $O(n)$

Search has a linear time complexity, since we have to traverse the list: $O(n)$

Linked lists are not contiguous in memory, which means traversal can be costly and lack the memory optimization benefits of contiguous data structures.

### Complexity Summary

| Operation               | Singly                 | Doubly |
| ----------------------- | ---------------------- | ------ |
| Insert at head          | O(1)                   | O(1)   |
| Insert at tail          | O(n) (unless tail ptr) | O(1)   |
| Delete at head          | O(1)                   | O(1)   |
| Delete at tail          | O(n)                   | O(1)   |
| Insert/delete in middle | O(1)*                  | O(1)*  |
| Search                  | O(n)                   | O(n)   |

* Requires references to the node; otherwide finding the node is $O(n)$

### Downsides of Linked Lists

- Non contiguous memory: Poor cache locality
- Pointer chasing: Slow traversal
- More memory overhead (pointers)
- No indeces: no random access

This makes linked lists often slower than arrays.

## Implementation

### Node structure

```ts
class Node<T> {
    value: T;
    next: Node<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }
}
```

### Singly Linked List
```ts
class LinkedList<T> {
    private head: Node<T> | null = null;
    private tail: Node<T> | null = null;
    private length = 0;

    size(): number {
        return this.length;
    }

    // Insert at end
    push(value: T): void {
        const node = { value: value } as Node<T>;

        // if no head, set head and tail to the new node
        if (!this.head) {
            this.head = this.tail = node;
        } else {
            // otherwise, set the next pointer of the tail to the new node
            this.tail!.next = node;
            // and update the tail
            this.tail = node;
        }

        this.length++;
    }

    // Insert at beginning
    unshift(value: T): void {
        const node = { value: value } as Node<T>;

        // if no head, set head and tail to the new node
        if (!this.head) {
            this.head = this.tail = node;
        } else {
            // otherwise, point the new node to the current head
            node.next = this.head;
            // and update the head
            this.head = node;
        }

        this.length++;
    }

    // Remove first element
    shift(): T | null {
        // if no head, return null
        if (!this.head) return null;

        // otherwise, store the value of the head
        const value = this.head.value;
        // and update the head
        this.head = this.head.next;

        // if we removed the last element, set tail to null
        if (!this.head) {
            this.tail = null;
        }

        // bookkeeping length
        this.length--;
        return value;
    }

    // Get by index (O(n))
    get(index: number): T | null {
        // if index is out of range, return null
        if (index < 0 || index >= this.length) return null;

        // otherwise, start at the head
        let curr = this.head;
        // and traverse the list
        for (let i = 0; i < index; i++) {
            curr = curr!.next;
        }

        return curr!.value;
    }
}
```

# Queue (FIFO)

Our first data structure on top of a Linked List is a Queue.
One of the most common data structure implemented.

A queue removes elements in the same order they were added. It is a FIFO structure, first in first out. Similar to a waiting line.

```
A -> B -> C -> D -> E
```
We have 2 key references:pointers to `head` and `tail`.

A is our head, E is our tail.

If we insert into the queue, we add to the tail. Updating the tail to point to the new node.

```ts
A -> B -> C -> D -> E -> F
this.tail.next = F // point the current tail to the new node
this.tail = F // set the tail to the new node
```

For a popping operation, we remove from the head, not the tail.

```ts
A -> B -> C -> D -> E -> F
h = head;
head = head.next;
h.next = null;
return h.value
```

The queue is constraining what we can do. 
We don't traverse anything.
We update head and tail.

pushing and popping (enqueuing and dequeuing) into a queue is $O(1)$, constant time.

Another operation common in queue is peeking, which is getting the value at the head without removing it.

Wat makes a lot of data structures fast is the lack of features.

## Implementing Queue

```ts
type Node<T> = {
    value: T;
    next?: Node<T>;
}

export default class Queue<T> {
    public length: number;

    private head?: Node<T>;
    private tail?: Node<T>;

    constructor() {
        this.head = this.tail = undefined;
        this.length = 0;
    }

    // add node to the end
    enqueue(item: T): void {

        // new node
        const node = { value: item } as Node<T>;

        // keep track of the length
        this.length++;

        // if no tail, set head and tail to the new node
        if (!this.tail) {
            this.head = this.tail = node;
            return;
        }

        // otherwise, add to the end
        // point the current tail to the new node
        this.tail.next = node;
        // update the tail
        this.tail = this.tail.next;

    }

    // remove node from the beginning and return the value
    deque(): T | undefined {
        if (!this.head) {
            return undefined;
        }

        // take current head
        const node = this.head;
        // update head
        this.head = node.next;
        // keep track of the length
        this.length--;

        // if in traditional languages with no garbage collector, we have to free the memory
        // this.head.next = undefined;

        // if no head, set tail to undefined
        if (!this.head) {
            this.tail = undefined;
        }

        return node.value

    }

    // return the value of the head
    peek(): T | undefined {
        return this.head?.value
        // return value of head if not undefined, otherwise undefined
    }
} 
```

# Stack (LIFO)

A stack removes the most recently added item. It is a queue but backwards. A singly linked list where elements are added and removed inly from the head, following a LIFO order (last in, first out).


```txt
Top of stack
  |
  V
[ E ]
[ D ]
[ C ]
[ B ]
[ A ] <- Bottom
```

E is our head. We add and remove from our head.
We can see it as a stack of plates.

To add a new element we take a new element F and point it to the current head. Then we update the head to point to F.

We remove a node by saving the head, then updating the head to the next (or previous, depending on how we implement it) node. And then we return the value of the removed node.

The stack also have a peek operation.

We see stack all over the place.
When we will do recursion, we can see calling functions as a stack.

Stack is again a data structure with constraints.
By only allowing pushing and popping from one side, the time complexity for pushing and popping is constant: $O(1)$

## Implementing Stack

```ts
type Node<T> = {
    value: T;
    prev?: Node<T>;
}

export default class Stack<T> {
    public length: number;

    private head?: Node<T>;

    constructor() {
        this.head = undefined;
        this.length = 0;
    }

    push(item: T): void {
        const node = { value: item } as Node<T>;

        // bookkeeping length
        this.length++;

        // if no head, set head to the new node
        if (!this.head) {
            this.head = node;
        }

        // otherwise, add to the end
        else {
            // take our node and point it to the current head
            node.prev = this.head;
            // update the head
            this.head = node;
        }
    }
    pop(): T | undefined {
        // bookkeeping
        this.length = Math.max(0, this.length - 1);

        // if queue is empty
        if (this.length === 0) {
            const node = this.head;
            this.head = undefined;
            return node?.value;
        }

        // otherwise, remove from the beginning
        else {
            // take the current head
            const node = this.head as Node<T>;
            // update the head
            this.head = node.prev;
            // return the value of the removed node
            return node.value;
        }

    }
    peek(): T | undefined {
        return this.head?.value
    }
}
```

# Summary

### Bubble Sort

- Simple but slow: $O(n^2)$
- Fundamental sorting concepts

### Linked Lists

- Fast insertions and deletions: $O(1)$
- Slow searches: $O(n)$
- No random access: $O(n)$
- No index: $O(n)$
- Often slower than arrays in practice

### Queue

- FIFO
- Built on top of linked lists
- Enqueue: $O(1)$
- Dequeue: $O(1)$
- Peek: $O(1)$

### Stack

- LIFO
- Built on top of linked lists
- Used everywhere in programming
- Push: $O(1)$
- Pop: $O(1)$
- Peek: $O(1)$