# Arrays — Deep Dive

## What is an array?

At a high level, `const a = []` looks like an array in JavaScript. However, JavaScript's `Array` is a dynamic, resizable, object-backed structure, not the low-level fixed-size contiguous array used in systems programming and data-structure theory.

A true (low-level) array is:
> a fixed-size, contiguous block of memory where each element occupies equal width and the address of an element can be computed as
>
> $$\text{address} = \text{base} + \text{index} \cdot \text{elementWidth}$$

This is the core idea behind real arrays.

## Low-level arrays (real arrays)

A real array typically requires:
- Contiguous memory
- Fixed size (cannot grow or shrink)
- Homogeneous data type (equal width per element)
- Indexing via pointer arithmetic

Example (C-like): `a = int[3]` — an array of 3 integers (assuming 4 bytes each) occupies 12 bytes. The addresses are:
- `a[0]`: `base + 0 * 4`
- `a[1]`: `base + 1 * 4`
- `a[2]`: `base + 2 * 4`

This arithmetic guarantees O(1) random access.

## Typed arrays / ArrayBuffer (JS example)

```node
> const a = new ArrayBuffer(6);
undefined
> a
ArrayBuffer { [Uint8Contents]: <00 00 00 00 00 00>, byteLength: 6 }
> const a8 = new Int8Array(a);
undefined
> a8[0] = 45;
45
> a
ArrayBuffer { [Uint8Contents]: <2d 00 00 00 00 00>, byteLength: 6 }
> a8[2] = 42;
42
> a
ArrayBuffer { [Uint8Contents]: <2d 00 2a 00 00 00>, byteLength: 6 }
```

We created a raw 6-byte buffer, then viewed it as an array of 8-bit integers (`Int8Array`). Writing to `a8[0]` writes the first byte; writing to `a8[2]` writes the third byte.

Now reinterpret the same buffer as 16-bit integers:

```node
> const a16 = new Int16Array(a);
undefined
> a16[2] = 0x4545;
17733
> a
ArrayBuffer { [Uint8Contents]: <2d 00 2a 00 45 45>, byteLength: 6 }
```

Interpreting the same 6 bytes as 16-bit elements lets us store three 16-bit values. Writing to `a16[2]` overwrites bytes 4 and 5 of the buffer. The buffer contents are now:

- As `Int8Array`: `2d | 00 | 2a | 00 | 45 | 45`
- As `Int16Array`: `2d 00 | 2a 00 | 45 45`

Both `a8` and `a16` point to the same underlying memory; they are different views on the same contiguous block.

### Takeaway
- Low-level arrays: contiguous memory, fixed element width, pointer arithmetic indexing.
- JavaScript `Array` is a high-level, dynamic structure that hides these details.

## JavaScript `[]` vs. true arrays

JavaScript arrays (`[]`) are:
- Dynamic (auto-resize)
- Potentially sparse (can skip elements)
- Store elements as references (boxed values)
- Implemented as objects internally (engines may optimize to packed mode)

They behave like arrays from a high level, but are not the `int[N]` arrays referred to in DSA.

## Core operations and their complexity

Let's practice Big-O with common array operations:
- Access element at index
- Insert at specific index
- Delete at specific index

### Access element at index — O(1)

Address computation is constant-time:

$$\text{address} = \text{baseAddress} + (\text{index} \cdot \text{width})$$

- No loops, no traversal → O(1).

### Insert at index (true fixed-size array) — O(1) (overwrite)

True fixed-size arrays cannot grow. Assigning to an index overwrites the slot:

```ts
const a = [1, 2, 3, 4, 5];
a[2] = 10; // overwrite
```

Shifting elements (e.g., `array.splice`) is an operation on a dynamic array that involves moving elements.

### Delete at index (true fixed-size array) — O(1)

Deletion is typically implemented by overwriting or marking the slot. Memory remains allocated; the array size does not change.

## Array vs Dynamic Array

**True low-level arrays**
- Fixed size
- Contiguous memory
- O(1) indexing
- Cannot insert/remove without overwriting
- Cannot grow/shrink

**Dynamic arrays** (JS `Array`, Python `list`, C++ `vector`, Java `ArrayList`)
- Resize automatically
- Append amortized O(1)
- Insert/delete may require shifting elements → O(n)
- Often double capacity when full

Dynamic arrays simulate low-level arrays while providing automatic resizing and conveniences.

## Memory layout of arrays

#### Arrays require:
- contiguous memory
- equal element widths

#### Why this matters:
- super-fast pointer arithmetic
- predictable memory access (cache-friendly)
- SIMD operations possible
- CPU prefetch optimizations

# Array Big-O Summary
| Operation | True Array | Dynamic Array |
| --- | ---: | ---: |
| Access index `a[i]` | O(1) | O(1) |
| Insert at index (overwrite) | O(1) | O(n) |
| Insert at end (push) | not allowed | Amortized O(1) |
| Delete at index (overwrite) | O(1) | O(n) |
| Shift elements | not allowed | O(n) |
| Resize | not allowed | O(n) |

