# Search Algorithms

Search algorithms are fundamental in data structures and algorithms. This lesson covers:

- Linear Search — $O(n)$
- Binary Search — $O(\log n)$
- The two-crystal-balls / $\sqrt{n}$ jump-search idea

We focus on intuition, implementation, Big‑O, and practical considerations.

## 1. Premises

For teaching purposes:
- We will pretend that JavaScript actually has arrays.
- We only have access to the `.length` property of an array.
- We will not go full C neckbeard and require length to be passed in.

We will be visualizing the problem first, discussing it with boxes, circles and arrows, and then program it. Its definitely a core competency that will follow you for life.

# 2. Linear Search

Linear search scans the array from left to right until it finds the target or reaches the end.

### Idea

Scan until:
- target found → return `true` (or index)
- array ends → return `false` (or `-1`)

```ts
export default function linear_search(haystack: number[], needle: number): boolean {
    for (let i = 0; i < haystack.length; ++i) {
        if (haystack[i] === needle) {
            return true;
        }
    }
    return false;
}
```

### Complexity

- Time (worst case): $O(n)$ — may need to examine every element
- Space: $O(1)$ — constant extra space

### Notes

- Works on unsorted arrays
- Simple and stable, but slow for large arrays
- Average case is $\Theta(n)$
- Often used for small arrays where setup/overhead of more complex algorithms is not worth it

## 3. Binary Search

Binary search is one of the most important algorithms in computer science.

**Precondition:** the array must be sorted.

### Idea

If the array is sorted, compare the target to the middle element and eliminate half the search space each step:

- If middle == target → found
- If middle < target → search right half
- If middle > target → search left half

Repeating this halves the search space each step.

### Complexity intuition

If the search space is halved each step, after $k$ steps the remaining size is $n / 2^k$. When this equals 1:

$$\frac{n}{2^k} = 1 \Rightarrow n = 2^k \Rightarrow k = \log_2 n$$

So binary search runs in $O(\log n)$ time and $O(1)$ space (iterative).

### Complexity summary

| Condition | Complexity |
| ---: | :--- |
| Best case | $O(1)$ |
| Worst case | $O(\log n)$ |
| Space (iterative) | $O(1)$ |
| Space (recursive) | $O(\log n)$ (call depth) |

### Implementation (iterative)

Use `lo = 0` and `hi = length - 1` and loop while `lo <= hi`.

```ts
export default function binarySearch(haystack: number[], needle: number): boolean {
  let lo = 0;
  let hi = haystack.length - 1;

  while (lo <= hi) {
    const m = Math.floor(lo + (hi - lo) / 2); // avoids overflow
    const v = haystack[m];
    if (v === needle) return true;
    if (v < needle) lo = m + 1;
    else hi = m - 1;
  }

  return false;
}
```

### Variants worth knowing

- First/last occurrence (lower_bound / upper_bound)
- Find insertion index
- Binary search on the answer (used in optimization/DP)
- Search in rotated sorted arrays
- Search in infinite/unbounded arrays (exponential search to find range)

## 4. Two-Crystal-Balls / $\sqrt{n}$ Jump Search

This problem models finding the first `true` in a boolean array where querying too high may "break" a resource. The goal is to minimize worst-case checks given two usable probes.

### Why not linear search?

Linear search works but can be slow: $O(n)$ checks in the worst case.

### Why not binary search?

Binary search may break a ball early, forcing a linear scan with the remaining ball over half the array: worst-case cost becomes $O(n)$.

### Jump-search idea

Jump by blocks of size $k$ until a `true` is found, then linear-scan backward within the previous block. Worst-case cost:

$$\frac{n}{k} + k$$

Choose $k$ to minimize this expression. Treating $k$ as continuous and differentiating:

$$f(k)=\frac{n}{k}+k,\quad f'(k)=-\frac{n}{k^2}+1$$

$$f'(k)=0$$

$$n/k^2 = 1$$

$$k=\sqrt{n}$$

Then worst-case cost is $2\sqrt{n}=O(\sqrt{n})$.

So:

- Phase 1: jump by $\sqrt{n}$ until a `true` is found
- Phase 2: linear search up to $\sqrt{n}$ elements backward

### Implementation

```ts
export default function two_crystal_balls(breaks: boolean[]): number {

    const jumps = Math.floor(Math.sqrt(breaks.length));

    // find the first break
    let i = jumps;
    for (; i < breaks.length; i += jumps) {
        if (breaks[i]) {
            break;
        }
    }

    // walk back one increment
    i -= jumps;
    // walk frwards
    for (let j = 0; j < jumps && i < breaks.length; ++j, ++i) {
        if (breaks[i]) {
            return i;
        }
    }

    return -1;
}
```

## 5. Additional search algorithms

### 5.1 Exponential Search

Useful for unbounded/infinite arrays: first find a range by doubling (1, 2, 4, 8, ...), then binary search inside the found range. Complexity: $O(\log n)$.

### 5.2 Interpolation Search

Uses value distribution to pick better midpoints (good for uniformly distributed numeric arrays). Best: $O(\log\log n)$, worst: $O(n)$.

### 5.3 Jump Search (general form)

Generalization of the $\sqrt{n}$ idea; complexity depends on chosen jump size.

### 5.4 Ternary Search

Used for unimodal ("mountain") functions to find maximum/minimum; complexity: $O(\log n)$.

### 5.5 Fibonacci Search

Comparison-based technique using Fibonacci numbers to pick split points for searching in a sorted array. Complexity: $O(\log n)$.

## 6. Summary

| Algorithm             | Requires sorted?  |Worst-case time                | Best use case                                 |
| ---                   | :---:             | ---:                          | ---                                           |
| Linear search         | No                | $O(n)$                        | Small or unsorted arrays                      |
| Binary search         | Yes               | $O(\log n)$                   | Sorted arrays                                 |
| Jump search ($\sqrt{n}$) | Yes            | $O(\sqrt{n})$                 | Large sorted arrays when block jumps help     |
| Two-crystal-balls     | Yes               | $O(\sqrt{n})$                 | Minimize worst-case checks with two probes    |
| Exponential search    | Yes (implicitly)  | $O(\log n)$                   | Very large or unknown-size arrays             |
| Interpolation search  | Yes               | Varies (best $O(\log\log n)$) | Uniform numeric arrays                        |




